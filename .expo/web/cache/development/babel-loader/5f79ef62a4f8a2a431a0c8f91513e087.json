{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as tf from '@tensorflow/tfjs';\nimport * as FileSystem from 'expo-file-system';\nimport { bundleResourceIO, decodeJpeg } from '@tensorflow/tfjs-react-native';\nimport Image from \"react-native-web/dist/exports/Image\";\nimport { AppConfig } from \"../config\";\n\nvar imageToTensor = function imageToTensor(rawImageData) {\n  return decodeJpeg(rawImageData);\n};\n\nvar fetchImage = function fetchImage(image) {\n  var imgB64, imageAssetPath, imgBuffer, rawImageData;\n  return _regeneratorRuntime.async(function fetchImage$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!image.base64) {\n            _context.next = 4;\n            break;\n          }\n\n          imgB64 = image.base64;\n          _context.next = 9;\n          break;\n\n        case 4:\n          imageAssetPath = Image.resolveAssetSource(image);\n          console.log(imageAssetPath.uri);\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(FileSystem.readAsStringAsync(imageAssetPath.uri, {\n            encoding: FileSystem.EncodingType.Base64\n          }));\n\n        case 8:\n          imgB64 = _context.sent;\n\n        case 9:\n          imgBuffer = tf.util.encodeString(imgB64, 'base64').buffer;\n          rawImageData = new Uint8Array(imgBuffer);\n          return _context.abrupt(\"return\", rawImageData);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar preprocessImage = function preprocessImage(img, imageSize) {\n  var imageTensor = img.resizeBilinear([imageSize, imageSize]).toFloat();\n  var offset = tf.scalar(224);\n  var normalized = imageTensor.sub(offset).div(offset);\n  var preProcessedImage = imageTensor.reshape([-1, imageSize, imageSize, 3]);\n  return preProcessedImage;\n};\n\nvar decodePredictions = function decodePredictions(predictions, classes) {\n  var topK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n\n  var _predictions$topk = predictions.topk(topK),\n      values = _predictions$topk.values,\n      indices = _predictions$topk.indices;\n\n  var topKValues = values.dataSync();\n  var topKIndices = indices.dataSync();\n  var topClassesAndProbs = [];\n\n  for (var i = 0; i < topKIndices.length; i++) {\n    topClassesAndProbs.push({\n      className: classes[topKIndices[i]],\n      probability: topKValues[i]\n    });\n  }\n\n  return topClassesAndProbs;\n};\n\nexport var ModelService = function () {\n  function ModelService(imageSize, model, model_classes) {\n    _classCallCheck(this, ModelService);\n\n    this.imageSize = imageSize;\n    this.model = model;\n    this.model_classes = model_classes;\n  }\n\n  _createClass(ModelService, [{\n    key: \"classifyImage\",\n    value: function classifyImage(image) {\n      var _this = this;\n\n      var predictionResponse, imgBuffer, timeStart;\n      return _regeneratorRuntime.async(function classifyImage$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              predictionResponse = {\n                timing: null,\n                predictions: null,\n                error: null\n              };\n              _context2.prev = 1;\n              console.log(\"Classifying Image: Start \");\n              _context2.next = 5;\n              return _regeneratorRuntime.awrap(fetchImage(image));\n\n            case 5:\n              imgBuffer = _context2.sent;\n              timeStart = new Date().getTime();\n              console.log(\"Backend: \" + tf.getBackend() + \" \");\n              tf.tidy(function () {\n                console.log(\"Fetching Image: Start \");\n                var imageTensor = imageToTensor(imgBuffer);\n                console.log(\"Fetching Image: Done \");\n                var timeLoadDone = new Date().getTime();\n                console.log(\"Preprocessing image: Start\");\n                var preProcessedImage = preprocessImage(imageTensor, _this.imageSize);\n                console.log(\"Preprocessing image: Done\");\n                var timePrepocessDone = new Date().getTime();\n                console.log(\"Prediction: Start\");\n\n                var predictionsTensor = _this.model.predict(preProcessedImage);\n\n                console.log(\"Prediction: Done\");\n                var timePredictionDone = new Date().getTime();\n                console.log(\"Post Processing: Start\");\n                predictionResponse.predictions = decodePredictions(predictionsTensor, _this.model_classes, AppConfig.topK);\n                console.log(\"Post Processing: Done\");\n                var timeEnd = new Date().getTime();\n                var timing = {\n                  totalTime: timeEnd - timeStart,\n                  imageLoadingTime: timeLoadDone - timeStart,\n                  imagePreprocessing: timePrepocessDone - timeLoadDone,\n                  imagePrediction: timePredictionDone - timePrepocessDone,\n                  imageDecodePrediction: timeEnd - timePredictionDone\n                };\n                predictionResponse.timing = timing;\n              });\n              console.log(\"Classifying Image: End \");\n              console.log(\"Response:  \" + JSON.stringify(predictionResponse, null, 2) + \" \");\n              return _context2.abrupt(\"return\", predictionResponse);\n\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](1);\n              console.log('Exception Error: ', _context2.t0);\n              return _context2.abrupt(\"return\", {\n                error: _context2.t0\n              });\n\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, [[1, 14]], Promise);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(imageSize) {\n      var modelJSON, modelWeights, model_classes, model;\n      return _regeneratorRuntime.async(function create$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (ModelService.instance) {\n                _context3.next = 11;\n                break;\n              }\n\n              _context3.next = 3;\n              return _regeneratorRuntime.awrap(tf.ready());\n\n            case 3:\n              modelJSON = require(\"../assets/model_tfjs/model.json\");\n              modelWeights = require(\"../assets/model_tfjs/group1-shard1of1.bin\");\n              model_classes = require(\"../assets/model_tfjs/classes.json\");\n              _context3.next = 8;\n              return _regeneratorRuntime.awrap(tf.loadGraphModel(bundleResourceIO(modelJSON, modelWeights)));\n\n            case 8:\n              model = _context3.sent;\n              model.predict(tf.zeros([1, imageSize, imageSize, 3]));\n              ModelService.instance = new ModelService(imageSize, model, model_classes);\n\n            case 11:\n              return _context3.abrupt(\"return\", ModelService.instance);\n\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n\n  return ModelService;\n}();","map":{"version":3,"sources":["/Users/ankitmehta/Desktop/picturesque2.0/components/ModelService.tsx"],"names":["tf","FileSystem","bundleResourceIO","decodeJpeg","AppConfig","imageToTensor","rawImageData","fetchImage","image","base64","imgB64","imageAssetPath","Image","resolveAssetSource","console","log","uri","readAsStringAsync","encoding","EncodingType","Base64","imgBuffer","util","encodeString","buffer","Uint8Array","preprocessImage","img","imageSize","imageTensor","resizeBilinear","toFloat","offset","scalar","normalized","sub","div","preProcessedImage","reshape","decodePredictions","predictions","classes","topK","topk","values","indices","topKValues","dataSync","topKIndices","topClassesAndProbs","i","length","push","className","probability","ModelService","model","model_classes","predictionResponse","timing","error","timeStart","Date","getTime","getBackend","tidy","timeLoadDone","timePrepocessDone","predictionsTensor","predict","timePredictionDone","timeEnd","totalTime","imageLoadingTime","imagePreprocessing","imagePrediction","imageDecodePrediction","JSON","stringify","instance","ready","modelJSON","require","modelWeights","loadGraphModel","zeros"],"mappings":"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","sourcesContent":["import * as tf from '@tensorflow/tfjs';\nimport * as FileSystem from 'expo-file-system'\nimport { fetch ,asyncStorageIO,bundleResourceIO,decodeJpeg} from '@tensorflow/tfjs-react-native'\nimport {Image} from 'react-native';\nimport * as ImageManipulator from 'expo-image-manipulator';\nimport {AppConfig} from \"../config\"\nimport { ThemeConsumer } from 'react-native-elements';\n\nexport interface ModelPrediction {\n  className:string;\n  probability:number;\n}\n\nexport interface IModelPredictionTiming {\n  totalTime:number;\n  imageLoadingTime:number;\n  imagePreprocessing:number;\n  imagePrediction:number;\n  imageDecodePrediction:number;\n}\n\nexport interface IModelPredictionResponse {\n  predictions?:ModelPrediction[] | null\n  timing?:IModelPredictionTiming | null\n  error?:string | null\n}\n\nconst imageToTensor = (rawImageData:Uint8Array)=> {\n  return decodeJpeg(rawImageData);\n}\n\n\nconst fetchImage = async (image:ImageManipulator.ImageResult) => {\n  let imgB64:string;\n  if(image.base64){\n    imgB64=image.base64\n  }else{ \n    const imageAssetPath = Image.resolveAssetSource(image)\n    console.log(imageAssetPath.uri);\n  \n    imgB64 = await FileSystem.readAsStringAsync(imageAssetPath.uri, {\n      encoding: FileSystem.EncodingType.Base64,\n    });\n  }\n \n  const imgBuffer = tf.util.encodeString(imgB64, 'base64').buffer;\n  const rawImageData = new Uint8Array(imgBuffer)  \n\n  return rawImageData;\n}\nconst preprocessImage = (img:tf.Tensor3D,imageSize:number) =>{\n      // https://github.com/keras-team/keras-applications/blob/master/keras_applications/imagenet_utils.py#L43\n\n      let imageTensor = img.resizeBilinear([imageSize, imageSize]).toFloat();\n\n      const offset = tf.scalar(224);\n      const normalized = imageTensor.sub(offset).div(offset);\n      const preProcessedImage = imageTensor.reshape([-1, imageSize, imageSize, 3]);\n      return preProcessedImage;\n      \n}\n\nconst decodePredictions = (predictions:tf.Tensor, classes:String[],topK=3) =>{\n  const {values, indices} = predictions.topk(topK);\n  const topKValues = values.dataSync();\n  const topKIndices = indices.dataSync();\n\n  const topClassesAndProbs:ModelPrediction[] = [];\n  for (let i = 0; i < topKIndices.length; i++) {\n    topClassesAndProbs.push({\n      className: classes[topKIndices[i]],\n      probability: topKValues[i]\n    } as ModelPrediction);\n  }\n  return topClassesAndProbs;\n}\n\n\nexport class ModelService {\n\n    private model:tf.GraphModel;\n    private model_classes: String[];\n    private imageSize:number;\n    private static instance: ModelService;\n\n    constructor(imageSize:number,model:tf.GraphModel, model_classes: String[] ){\n        this.imageSize=imageSize;\n        this.model = model;\n        this.model_classes=model_classes;\n    }\n\n\n    static async create(imageSize:number) {\n      if (!ModelService.instance){\n        await tf.ready();\n        const modelJSON = require('../assets/model_tfjs/model.json');\n        const modelWeights = require('../assets/model_tfjs/group1-shard1of1.bin');\n        const model_classes = require(\"../assets/model_tfjs/classes.json\")\n\n        const model = await tf.loadGraphModel(bundleResourceIO(modelJSON, modelWeights));\n        model.predict(tf.zeros([1, imageSize, imageSize, 3]));\n        \n        ModelService.instance = new ModelService(imageSize,model,model_classes);\n      }\n\n      return ModelService.instance;\n\n    }\n\n    async classifyImage(image:ImageManipulator.ImageResult):Promise<IModelPredictionResponse>{ \n      const predictionResponse = {timing:null,predictions:null,error:null} as IModelPredictionResponse;\n      try {\n          console.log(`Classifying Image: Start `)\n          \n          let imgBuffer:Uint8Array = await fetchImage(image); \n          const timeStart = new Date().getTime()\n          console.log(`Backend: ${tf.getBackend()} `)\n          tf.tidy(()=>{\n            console.log(`Fetching Image: Start `)\n          \n            const imageTensor:tf.Tensor3D = imageToTensor(imgBuffer);\n            \n            \n            console.log(`Fetching Image: Done `)\n            const timeLoadDone = new Date().getTime()\n      \n            console.log(\"Preprocessing image: Start\")\n            \n            const preProcessedImage = preprocessImage(imageTensor,this.imageSize); // Look at this line of code incase it improves accuracy.\n      \n            console.log(\"Preprocessing image: Done\")\n            const timePrepocessDone = new Date().getTime()\n      \n            console.log(\"Prediction: Start\")\n            const predictionsTensor:tf.Tensor = this.model.predict(preProcessedImage) as tf.Tensor;\n            console.log(\"Prediction: Done\")\n            const timePredictionDone = new Date().getTime()\n      \n            console.log(\"Post Processing: Start\")\n      \n            // post processing\n            predictionResponse.predictions  = decodePredictions(predictionsTensor,this.model_classes,AppConfig.topK);\n            \n            \n            //tf.dispose(imageTensor);\n            //tf.dispose(preProcessedImage);\n            //tf.dispose(predictions);\n\n            console.log(\"Post Processing: Done\")\n\n            const timeEnd = new Date().getTime()\n            \n            const timing:IModelPredictionTiming = {\n              totalTime: timeEnd-timeStart,\n              imageLoadingTime : timeLoadDone-timeStart,\n              imagePreprocessing : timePrepocessDone-timeLoadDone,\n              imagePrediction : timePredictionDone-timePrepocessDone ,\n              imageDecodePrediction : timeEnd-timePredictionDone\n            } as IModelPredictionTiming;\n            predictionResponse.timing = timing;\n\n          });\n          \n          \n          console.log(`Classifying Image: End `);\n\n          console.log(`Response:  ${JSON.stringify(predictionResponse ,null, 2 ) } `);\n          return predictionResponse as IModelPredictionResponse\n          \n      } catch (error) {\n          console.log('Exception Error: ', error)\n          return {error}\n      }\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}